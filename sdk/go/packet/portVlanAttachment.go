// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package packet

import (
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// Provides a resource to attach device ports to VLANs.
// 
// Device and VLAN must be in the same facility.
// 
// If you need this resource to add the port back to bond on removal, set `force_bond = true`.
// 
// To learn more about Layer 2 networking in Packet, refer to
// * https://support.packet.com/kb/articles/layer-2-configurations
// * https://support.packet.com/kb/articles/layer-2-overview
// 
// ## Attribute Referece
// 
// * `id` - UUID of device port used in the assignment
// * `vlan_id` - UUID of VLAN API resource
// * `port_id` - UUID of device port
type PortVlanAttachment struct {
	s *pulumi.ResourceState
}

// NewPortVlanAttachment registers a new resource with the given unique name, arguments, and options.
func NewPortVlanAttachment(ctx *pulumi.Context,
	name string, args *PortVlanAttachmentArgs, opts ...pulumi.ResourceOpt) (*PortVlanAttachment, error) {
	if args == nil || args.DeviceId == nil {
		return nil, errors.New("missing required argument 'DeviceId'")
	}
	if args == nil || args.PortName == nil {
		return nil, errors.New("missing required argument 'PortName'")
	}
	if args == nil || args.VlanVnid == nil {
		return nil, errors.New("missing required argument 'VlanVnid'")
	}
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["deviceId"] = nil
		inputs["forceBond"] = nil
		inputs["native"] = nil
		inputs["portName"] = nil
		inputs["vlanVnid"] = nil
	} else {
		inputs["deviceId"] = args.DeviceId
		inputs["forceBond"] = args.ForceBond
		inputs["native"] = args.Native
		inputs["portName"] = args.PortName
		inputs["vlanVnid"] = args.VlanVnid
	}
	inputs["portId"] = nil
	inputs["vlanId"] = nil
	s, err := ctx.RegisterResource("packet:index/portVlanAttachment:PortVlanAttachment", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &PortVlanAttachment{s: s}, nil
}

// GetPortVlanAttachment gets an existing PortVlanAttachment resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPortVlanAttachment(ctx *pulumi.Context,
	name string, id pulumi.ID, state *PortVlanAttachmentState, opts ...pulumi.ResourceOpt) (*PortVlanAttachment, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["deviceId"] = state.DeviceId
		inputs["forceBond"] = state.ForceBond
		inputs["native"] = state.Native
		inputs["portId"] = state.PortId
		inputs["portName"] = state.PortName
		inputs["vlanId"] = state.VlanId
		inputs["vlanVnid"] = state.VlanVnid
	}
	s, err := ctx.ReadResource("packet:index/portVlanAttachment:PortVlanAttachment", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &PortVlanAttachment{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *PortVlanAttachment) URN() *pulumi.URNOutput {
	return r.s.URN()
}

// ID is this resource's unique identifier assigned by its provider.
func (r *PortVlanAttachment) ID() *pulumi.IDOutput {
	return r.s.ID()
}

// ID of device to be assigned to the VLAN
func (r *PortVlanAttachment) DeviceId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["deviceId"])
}

// Add port back to the bond when this resource is removed. Default is false.
func (r *PortVlanAttachment) ForceBond() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["forceBond"])
}

// Mark this VLAN a native VLAN on the port. This can be used only if this assignment assigns second or further VLAN to the port. To ensure that this attachment is not first on a port, you can use `depends_on` pointing to another packet_port_vlan_attachment, just like in the layer2-individual example above. 
func (r *PortVlanAttachment) Native() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["native"])
}

func (r *PortVlanAttachment) PortId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["portId"])
}

// Name of network port to be assigned to the VLAN
func (r *PortVlanAttachment) PortName() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["portName"])
}

func (r *PortVlanAttachment) VlanId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["vlanId"])
}

// VXLAN Network Identifier, integer
func (r *PortVlanAttachment) VlanVnid() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["vlanVnid"])
}

// Input properties used for looking up and filtering PortVlanAttachment resources.
type PortVlanAttachmentState struct {
	// ID of device to be assigned to the VLAN
	DeviceId interface{}
	// Add port back to the bond when this resource is removed. Default is false.
	ForceBond interface{}
	// Mark this VLAN a native VLAN on the port. This can be used only if this assignment assigns second or further VLAN to the port. To ensure that this attachment is not first on a port, you can use `depends_on` pointing to another packet_port_vlan_attachment, just like in the layer2-individual example above. 
	Native interface{}
	PortId interface{}
	// Name of network port to be assigned to the VLAN
	PortName interface{}
	VlanId interface{}
	// VXLAN Network Identifier, integer
	VlanVnid interface{}
}

// The set of arguments for constructing a PortVlanAttachment resource.
type PortVlanAttachmentArgs struct {
	// ID of device to be assigned to the VLAN
	DeviceId interface{}
	// Add port back to the bond when this resource is removed. Default is false.
	ForceBond interface{}
	// Mark this VLAN a native VLAN on the port. This can be used only if this assignment assigns second or further VLAN to the port. To ensure that this attachment is not first on a port, you can use `depends_on` pointing to another packet_port_vlan_attachment, just like in the layer2-individual example above. 
	Native interface{}
	// Name of network port to be assigned to the VLAN
	PortName interface{}
	// VXLAN Network Identifier, integer
	VlanVnid interface{}
}
